use std::{borrow::Cow, sync::Arc};

use bindings::Bindings;
use geometry::{Geometry, Vertex};
use gpu::{GeoBuffers, GPU};
use wgpu::{util::BufferInitDescriptor, BindGroup, PipelineLayout, RenderPipeline, ShaderModule};
use winit::window::Window;

pub mod bindings;
pub mod geometry;
pub mod gpu;

pub trait Bufferize: Sized {
    fn descriptor(&self) -> BufferInitDescriptor;
}

const BLACK: wgpu::Color = wgpu::Color { r: 0., g: 0., b: 0., a: 1. };

pub struct Graphics {
    surface: wgpu::Surface<'static>,
    gpu: GPU,
    config: wgpu::SurfaceConfiguration,
    size: winit::dpi::PhysicalSize<u32>,
}

impl Graphics {
    pub fn new(window: Arc<Window>) -> Self {
        let size = window.inner_size();

        let instance = wgpu::Instance::new(&wgpu::InstanceDescriptor {
            backends: wgpu::Backends::all(),
            ..Default::default()
        });

        // # Safety
        //
        // The surface needs to live as long as the window that created it.
        // State owns the window, so this should be safe.
        let surface= instance.create_surface(window).unwrap();

        let (gpu, surface_caps) = GPU::new(&instance, &surface);

        // Shader code in this tutorial assumes an sRGB surface texture. Using a different
        // one will result in all the colors coming out darker. If you want to support non
        // sRGB surfaces, you'll need to account for that when drawing to the frame.
        let surface_format = surface_caps.formats.iter()
            .copied()
            .filter(|f| f.is_srgb())
            .next()
            .unwrap_or(surface_caps.formats[0]);
        let config = wgpu::SurfaceConfiguration {
            usage: wgpu::TextureUsages::RENDER_ATTACHMENT,
            format: surface_format,
            width: size.width,
            height: size.height,
            present_mode: surface_caps.present_modes[0],
            alpha_mode: surface_caps.alpha_modes[0],
            view_formats: vec![],
            desired_maximum_frame_latency: 2,
        };
        surface.configure(&gpu.device, &config);

        Self {
            surface,
            gpu,
            config,
            size,
        }
    }

    /**
    Produces a `RenderPipeline` and `Vec<BindGroup>` from a `Material`.

    Although it is possible to pass in multiple vertex buffers when creating a `RenderPipeline`,
    the location of vertex data is still determined by the shader location field of the vertex attribute.
    That means even if you add multiple buffers, you must still avoid location collisions.
    To avoid dealing with that complexity, each `RenderPipeline` will use a single vertex buffer,
    with locations of struct fields generated by the `VertexLayout` derive macro in sequential order.
    */
    pub fn pipeline<V: Vertex>(&self, material: &Material) -> (RenderPipeline, Vec<BindGroup>) {
        let shader = self.gpu.device.create_shader_module(wgpu::ShaderModuleDescriptor {
            label: Some("test"),
            source: wgpu::ShaderSource::Wgsl(Cow::Borrowed(&material.shader)),
        });

        let (layout, groups) = self.gpu.prepare_groups(&material.bindings, None);
        
        let pipeline = self.gpu.device.create_render_pipeline(&wgpu::RenderPipelineDescriptor {
            label: Some("Render Pipeline"),
            layout: Some(&layout),
            vertex: wgpu::VertexState {
                module: &shader,
                entry_point: Some("vs_main"), // 1.
                buffers: &[
                    V::LAYOUT,
                ],
                compilation_options: wgpu::PipelineCompilationOptions::default(),
            },
            fragment: Some(wgpu::FragmentState { // 3.
                module: &shader,
                entry_point: Some("fs_main"),
                targets: &[Some(wgpu::ColorTargetState { // 4.
                    format: self.config.format,
                    blend: Some(wgpu::BlendState::ALPHA_BLENDING),
                    write_mask: wgpu::ColorWrites::ALL,
                })],
                compilation_options: wgpu::PipelineCompilationOptions::default(),
            }),
            // continued ...
            primitive: wgpu::PrimitiveState {
                topology: wgpu::PrimitiveTopology::TriangleStrip, // 1.
                strip_index_format: None,
                front_face: wgpu::FrontFace::Cw, // 2.
                cull_mode: Some(wgpu::Face::Back),
                // Setting this to anything other than Fill requires Features::NON_FILL_POLYGON_MODE
                polygon_mode: wgpu::PolygonMode::Fill,
                // Requires Features::DEPTH_CLIP_CONTROL
                unclipped_depth: false,
                // Requires Features::CONSERVATIVE_RASTERIZATION
                conservative: false,
            },
            depth_stencil: None, // 1.
            multisample: wgpu::MultisampleState {
                count: 1, // 2.
                mask: !0, // 3.
                alpha_to_coverage_enabled: false, // 4.
            },
            multiview: None, // 5.
            cache: None, // 6.
        });
        (pipeline, groups)
    }

    /**
    High level render function. Converts inputs into buffers before passing them to GPU.
    
    You can only have one vertex type in a render, so monomorphizing over that makes sense.
    We want to support arbitrary bound buffers, and the Bindings type takes care of that.
    */
    pub fn render<V: Vertex>(&self, pipeline: &RenderPipeline, groups: Vec<BindGroup>, geometries: &[Geometry<V>]) -> Result<(), wgpu::SurfaceError> {
        let geos: Vec<GeoBuffers> = geometries.iter().map(|geometry| self.gpu.geo_buffers(geometry)).collect();
        self.gpu.render(&self.surface, pipeline, &groups, &geos)
    }

    pub fn resize(&mut self, new_size: winit::dpi::PhysicalSize<u32>) {
        if new_size.width > 0 && new_size.height > 0 {
            self.size = new_size;
            self.config.width = new_size.width;
            self.config.height = new_size.height;
            self.surface.configure(&self.gpu.device, &self.config);
        }
    }
}

/**
We couple the shader with the bindings for uniform and storage buffers.
*/
pub struct Material<'a> {
    shader: String,
    bindings: Vec<Bindings<'a>>,
}

impl<'a> Material<'a> {
    pub fn new(shader: &'a str) -> Self {
        Self {
            shader: std::fs::read_to_string(shader).expect("reading shader failed"),
            bindings: Vec::new(),
        }
    }

    pub fn attach(&mut self, group: Bindings<'a>) {
        self.bindings.push(group);
    }
}